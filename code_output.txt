新規データをいれてないのに、Pythonを実行すると、googleカレンダーのデータが更新されず、同じものが増えていく


---


- フォルダ名: .
- ファイル名: .env_sample
- 内容:
TIMETREE_EMAIL=(TIMETREEのメールアドレス)
TIMETREE_PASSWORD=（TIMETREEのパスワード）
TIMETREE_CALENDAR_URL=（TIMETREEで表示させたいカレンダーのURL）
GAS_WEBAPP_URL=（GASのURL）



---


- フォルダ名: .
- ファイル名: gas.gs
- 内容:
// このスクリプトが管理するイベントであることを示すための「目印」
const SYNC_TAG = '\u200B[TimeTree]\u200B'; // 見えない文字(ゼロ幅スペース)で囲んだタグ

/**
 * 12時間表記(AM/PM)の時刻文字列をパースして、Dateオブジェクトを生成するヘルパー関数
 * @param {string} dateStr - "YYYY-MM-DD"形式の日付文字列
 * @param {string} timeStr - "H:MM AM/PM"形式の時刻文字列
 * @returns {Date}
 */
function parseDateTime(dateStr, timeStr) {
  // この関数は変更なし
  const dateParts = dateStr.split('-');
  const year = parseInt(dateParts[0], 10);
  const month = parseInt(dateParts[1], 10) - 1;
  const day = parseInt(dateParts[2], 10);

  const timeMatch = timeStr.match(/(\d+):(\d+)\s(AM|PM)/);
  if (!timeMatch) return null; // 不正な形式の場合はnullを返す

  let hour = parseInt(timeMatch[1], 10);
  const minute = parseInt(timeMatch[2], 10);
  const ampm = timeMatch[3];

  if (ampm === 'PM' && hour < 12) {
    hour += 12;
  }
  if (ampm === 'AM' && hour === 12) {
    hour = 0;
  }

  return new Date(year, month, day, hour, minute);
}

/**
 * イベントのユニークなキーを生成する関数
 * @param {string} title - イベントのタイトル
 * @param {string} dateStr - "YYYY-MM-DD"形式の日付文字列
 * @returns {string} - "タイトル-YYYY-MM-DD" 形式のキー
 */
function createEventKey(title, dateStr) {
  return `${title}-${dateStr}`;
}

/**
 * WebアプリとしてPOSTリクエストを受け取ったときに実行されるメイン関数
 * @param {Object} e - POSTリクエストのイベントオブジェクト
 */
function doPost(e) {
  const logs = [];
  let statusMessage = "";
  let createdCount = 0;
  let updatedCount = 0;
  let deletedCount = 0;
  
  try {
    const timetreeEvents = JSON.parse(e.postData.contents);
    const calendar = CalendarApp.getDefaultCalendar();
    
    logs.push(`Received ${timetreeEvents.length} events to process from TimeTree.`);
    if (timetreeEvents.length === 0) {
      logs.push("No events to process. Sync finished.");
      return ContentService.createTextOutput(JSON.stringify({ status: "No events received.", logs: logs })).setMimeType(ContentService.MimeType.JSON);
    }

    // --- 1. 既存の同期済みイベントの名簿を作成 ---
    const firstEventDate = new Date(timetreeEvents[0].date);
    const year = firstEventDate.getFullYear();
    const month = firstEventDate.getMonth();
    const firstDayOfMonth = new Date(year, month, 1);
    const lastDayOfMonth = new Date(year, month + 1, 0, 23, 59, 59);

    const existingEvents = calendar.getEvents(firstDayOfMonth, lastDayOfMonth)
      .filter(event => {
        try {
          return event.getDescription().includes(SYNC_TAG);
        } catch (err) {
          return false;
        }
      });
      
    // 高速で検索できるように、既存イベントをMapに変換する
    const googleEventsMap = new Map();
    existingEvents.forEach(event => {
      const key = createEventKey(event.getTitle(), Utilities.formatDate(event.getStartTime(), Session.getScriptTimeZone(), "yyyy-MM-dd"));
      googleEventsMap.set(key, event);
    });
    logs.push(`Found ${googleEventsMap.size} existing synced events in Google Calendar for ${year}-${month + 1}.`);

    // --- 2. TimeTreeの予定を名簿と照合し、更新または新規作成 ---
    timetreeEvents.forEach(ttEvent => {
      const key = createEventKey(ttEvent.title, ttEvent.date);
      const options = { description: SYNC_TAG + "\n" + (ttEvent.memo || "") };

      if (googleEventsMap.has(key)) {
        // **【更新処理】** 既存の予定が見つかった場合
        const existingEvent = googleEventsMap.get(key);
        let needsUpdate = false;

        // メモの比較と更新
        if (existingEvent.getDescription() !== options.description) {
          existingEvent.setDescription(options.description);
          needsUpdate = true;
        }

        // 時間の比較と更新
        if (ttEvent.time) { // 時間指定イベントの場合
          const newStartTime = parseDateTime(ttEvent.date, ttEvent.time);
          const newEndTime = new Date(newStartTime.getTime() + (60 * 60 * 1000));
          if (existingEvent.getStartTime().getTime() !== newStartTime.getTime() || existingEvent.getEndTime().getTime() !== newEndTime.getTime()) {
            existingEvent.setTime(newStartTime, newEndTime);
            needsUpdate = true;
          }
        }
        
        if (needsUpdate) {
          logs.push(`Updating event: '${ttEvent.title}'`);
          updatedCount++;
        }
        
        googleEventsMap.delete(key); // 処理済みとして名簿から削除

      } else {
        // **【新規作成処理】** 既存の予定が見つからなかった場合
        logs.push(`Creating new event: '${ttEvent.title}'`);
        if (ttEvent.time) {
          const startTime = parseDateTime(ttEvent.date, ttEvent.time);
          const endTime = new Date(startTime.getTime() + (60 * 60 * 1000));
          calendar.createEvent(ttEvent.title, startTime, endTime, options);
        } else {
          const eventDate = new Date(ttEvent.date);
          const utcDate = new Date(eventDate.getUTCFullYear(), eventDate.getUTCMonth(), eventDate.getUTCDate());
          calendar.createAllDayEvent(ttEvent.title, utcDate, options);
        }
        createdCount++;
      }
    });

    // --- 3. 名簿に残り、不要になった予定を削除 ---
    if (googleEventsMap.size > 0) {
      logs.push(`Deleting ${googleEventsMap.size} events that no longer exist in TimeTree.`);
      googleEventsMap.forEach(eventToDelete => {
        logs.push(` - Deleting: '${eventToDelete.getTitle()}'`);
        eventToDelete.deleteEvent();
        deletedCount++;
      });
    }

    statusMessage = `Sync complete. Created: ${createdCount}, Updated: ${updatedCount}, Deleted: ${deletedCount}.`;
    logs.push(statusMessage);

  } catch (error) {
    statusMessage = "Error processing request: " + error.toString();
    logs.push(statusMessage, error.stack);
    logs.push("Received data: " + (e ? e.postData.contents : "N/A"));
  }
  
  return ContentService
    .createTextOutput(JSON.stringify({ status: statusMessage, logs: logs }))
    .setMimeType(ContentService.MimeType.JSON);
}


/**
 * GitHub Actionsのワークフローを起動します。
 */
function triggerGitHubActionsWorkflow() {
  // --- ▼ あなたの情報に合わせて変更してください ▼ ---
  const GITHUB_OWNER = 'epoch0718'; // あなたのGitHubユーザー名
  const GITHUB_REPO = 'py_timetree_googlecalender'; // リポジトリ名
  const WORKFLOW_FILE_NAME = 'main.yml';      // ワークフローのファイル名
  const GIT_BRANCH = 'main';                  // 対象のブランチ名
  // --- ▲ 設定ここまで ▲ ---

  // スクリプトプロパティから安全にPATを取得
  const GITHUB_PAT = PropertiesService.getScriptProperties().getProperty('GITHUB_PAT');
  
  if (!GITHUB_PAT) {
    Logger.log('エラー: スクリプトプロパティに GITHUB_PAT が設定されていません。');
    return;
  }

  const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/workflows/${WORKFLOW_FILE_NAME}/dispatches`;

  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${GITHUB_PAT}`
    },
    payload: JSON.stringify({
      'ref': GIT_BRANCH
    })
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    // レスポンスコード204は成功を意味する
    if (response.getResponseCode() === 204) {
      Logger.log('GitHub Actionsワークフローの起動に成功しました。');
    } else {
      Logger.log(`ワークフローの起動に失敗しました。ステータスコード: ${response.getResponseCode()}, レスポンス: ${response.getContentText()}`);
    }
  } catch (e) {
    Logger.log(`エラーが発生しました: ${e.toString()}`);
  }
}


---


- フォルダ名: .
- ファイル名: README.md
- 内容:
はい、承知いたしました。
`GAS`から`GitHub Actions`を起動する際に必要な`GITHUB_PAT`の登録手順も含めて、初心者の方にもさらに分かりやすくなるように全体を再構成し、README.mdを再出力します。

---

# TimeTree to Google Calendar Sync Tool 🤖

## 1. このツールで何ができるの？ 🤔

このツールは、**TimeTreeカレンダーに入力した予定を、自動的にあなたのGoogleカレンダーにコピー（同期）してくれる**便利なプログラムです。

一度設定してしまえば、あとはプログラムが定期的にTimeTreeをチェックし、Googleカレンダーを最新の状態に保ってくれます。これにより、以下のようなことが可能になります。

*   TimeTreeの予定を、Googleカレンダーと連携する他のサービス（例: Notion）で使えるようになります。
*   家族や友人とはTimeTreeで、個人の予定管理はGoogleカレンダーで、という使い分けがスムーズになります。

<br>

## 2. どんな仕組みで動いているの？ ⚙️

このツールは、3つの部品が連携して動作します。

1.  **Pythonスクリプト ( `timetree_scraper.py` )**
    *   あなたの代わりにTimeTreeのウェブサイトにログインし、カレンダーの予定（タイトル、日時、メモ）を読み取ります。ブラウザを自動で操作する「Playwright」という技術を使っています。

2.  **Google Apps Script ( `gas.gs` )**
    *   Pythonから受け取った予定のデータを使って、あなたのGoogleカレンダーに予定を書き込みます。一度書き込んだ予定は、TimeTree側で変更・削除されると、それに合わせてGoogleカレンダー側も自動で更新・削除される賢い仕組み（差分同期）になっています。
    *   また、「今すぐ同期したい！」という時のために、GitHub Actionsを呼び出すスイッチの役割も持っています。

3.  **GitHub Actions ( `.github/workflows/main.yml` )**
    *   この仕組み全体を、あなたが寝ている間も自動で動かし続けてくれる縁の下の力持ちです。設定した時間になると、自動的にPythonスクリプトを起動してくれます。

<br>

## 3. 必要なものリスト ✅

このツールを使うには、いくつかのアカウントや情報が必要です。

*   **TimeTreeのアカウント**
    *   ログイン用のメールアドレスとパスワード
    *   同期したいカレンダーのURL
*   **Googleのアカウント**
    *   同期先のGoogleカレンダー
*   **GitHubのアカウント**
    *   プログラムを設置し、自動実行させるための場所
*   **Pythonが動くパソコン**
    *   最初のセットアップや、手動でテストする時に使います。

---

## 4. セットアップ手順（使い方） 🚀

少し手順が多いですが、一つずつ丁寧に進めれば大丈夫です！

### ステップ1：Google側の準備（受付窓口＆手動スイッチを作る）

まず、Pythonから送られてくる予定データを受け取ったり、手動で同期を開始したりするための「基地」をGoogle Apps Script (GAS)で作成します。

1.  [Google Apps Script](https://script.google.com/home) にアクセスし、Googleアカウントでログインします。
2.  「**新しいプロジェクト**」を作成します。
3.  エディタが開いたら、最初から書かれているコードをすべて消し、`gas.gs`ファイルの中身を**すべてコピー＆ペースト**します。
4.  プロジェクトに名前をつけ（例: `TimeTree Sync`）、フロッピーディスクのアイコン💾を押して保存します。
5.  右上の青い「**デプロイ**」ボタンを押し、「**新しいデプロイ**」を選択します。
6.  歯車⚙️アイコンの「種類の選択」で「**ウェブアプリ**」を選びます。
7.  以下の設定を行います。
    *   **説明**: (任意) `TimeTree Sync WebApp` など
    *   **次のユーザーとして実行**: **自分**
    *   **アクセスできるユーザー**: **全員**
8.  「**デプロイ**」をクリックします。初回は、Googleカレンダーへのアクセス許可や外部URLへの接続許可などを求められるので、画面の指示に従って**すべて承認**してください。
9.  デプロイが完了すると「**ウェブアプリ URL**」が表示されます。このURLは後で使うので、**必ずコピーしてメモ帳などに保存**しておきましょう。

### ステップ2：GitHub側の準備（プログラムを設置する）

次に、このツール一式をあなたのGitHubアカウントに設置します。

1.  あなたのパソコンに、このプロジェクトのファイルをすべてダウンロード（または`git clone`）します。
2.  あなたのGitHubアカウントで、**新しいリポジトリ**を作成します。（リポジトリ名は `timetree-sync` など分かりやすいものが良いでしょう）
3.  ダウンロードしたプロジェクトのファイルを、作成した新しいリポジトリに**すべてアップロード（`git push`）**します。

### ステップ3：GitHubの「秘密鍵」を作成する (Personal Access Token)

GASがGitHub Actionsを安全に呼び出すための、特別な「秘密の合言葉」を作成します。

1.  GitHubにログインし、右上の自分のアイコンをクリック → **Settings** を選択。
2.  左側メニューを一番下までスクロールし、**< > Developer settings** を選択。
3.  **Personal access tokens** → **Tokens (classic)** を選択。
4.  **Generate new token** → **Generate new token (classic)** をクリック。
5.  **Note**に、トークンの名前を入力します（例: `GAS for TimeTree Scraper`）。
6.  **Expiration**（有効期限）を選択します。（セキュリティのため `30 days` や `90 days` が推奨されます）
7.  **Select scopes**（権限の選択）で、**`repo`** にチェックを入れます。
8.  一番下の **Generate token** ボタンをクリックします。
9.  **（最重要）** 緑色の背景に表示されるトークン（`ghp_...`で始まる文字列）を、**必ずコピーして安全な場所に保存します。この画面を一度閉じると、二度と表示されません。**

### ステップ4：秘密の情報を登録する

パスワードなどの大切な情報を、安全にプログラムへ渡すための設定です。

#### 4-1. GASに秘密の情報を登録する

1.  ステップ1で作成したGASプロジェクトに戻り、左側メニューの歯車⚙️アイコン「**プロジェクトの設定**」をクリック。
2.  「**スクリプト プロパティ**」セクションにある「**スクリプト プロパティを追加**」をクリック。
3.  以下の情報を登録します。
    *   **プロパティ**: `GITHUB_PAT`
    *   **値**: ステップ3でコピーした**Personal Access Token**の文字列 (`ghp_...`)
4.  「スクリプト プロパティを保存」をクリックします。

#### 4-2. GitHubに秘密の情報を登録する

1.  ステップ2で作成したあなたのGitHubリポジトリのページを開き、「**Settings**」タブ → 「**Secrets and variables**」 → 「**Actions**」に移動します。
2.  「**New repository secret**」ボタンを押し、以下の**4つの秘密の情報**を一つずつ登録していきます。
    *   **`TIMETREE_EMAIL`**: あなたのTimeTreeのログイン用メールアドレス
    *   **`TIMETREE_PASSWORD`**: あなたのTimeTreeのログイン用パスワード
    *   **`TIMETREE_CALENDAR_URL`**: 同期したいTimeTreeカレンダーのURL
    *   **`GAS_WEBAPP_URL`**: ステップ1でコピーした**ウェブアプリ URL**

### ステップ5：自動実行のスケジュールを設定する（お好みで）

`./github/workflows/main.yml` ファイルを開くと、自動実行のスケジュールを設定する箇所があります。

```yaml
schedule:
  - cron: "0 */1 * * *" # 1時間ごとに実行
```

この `cron` の設定を変更することで、実行頻度を自由に変えられます。（例: `0 */3 * * *` なら3時間ごと）
**注意**: 頻繁すぎる設定（10分ごとなど）は、アカウント停止のリスクやGitHubの無料枠を消費する可能性があるため、**1時間〜6時間ごと**を推奨します。

---

## 5. 使い方

*   **自動実行**: 上記の設定が完了していれば、あとは何もしなくてもGitHub Actionsが設定したスケジュール通りに自動で同期を実行してくれます。
*   **手動実行**: 「今すぐ同期したい！」という時は、**ステップ1で作成したGASプロジェクト**を開きます。エディタ上部の関数選択メニューから `triggerGitHubActionsWorkflow` を選び、再生ボタン▶️を押すことで、いつでも手動で同期を開始できます。

## 6. もしうまく動かない時は…？ 🛠️

*   **GitHub Actionsのログを確認**: 「Actions」タブの実行履歴から、エラーが出ていないか確認しましょう。赤い`X`マークがついていたら、ログにエラーの原因が書かれています。
*   **GASの実行履歴を確認**: [Google Apps Script](https://script.google.com/home) の該当プロジェクトを開き、左側メニューの「実行数」から、エラーが出ていないか確認できます。
*   **秘密の情報の再確認**: ステップ4で登録した情報に、打ち間違いやコピーミスがないか、もう一度確認してみてください。特にURLの最後のスラッシュ`/`などは要注意です。


---


- フォルダ名: .
- ファイル名: requirements.txt
- 内容:
playwright==1.55.0
python-dotenv
requests



---


- フォルダ名: .
- ファイル名: timetree_scraper.py
- 内容:
import os
import json
import requests
from playwright.sync_api import sync_playwright
from dotenv import load_dotenv
import re

load_dotenv()
TIMETREE_EMAIL = os.getenv("TIMETREE_EMAIL")
TIMETREE_PASSWORD = os.getenv("TIMETREE_PASSWORD")
CALENDAR_URL = os.getenv("TIMETREE_CALENDAR_URL")
GAS_WEBAPP_URL = os.getenv("GAS_WEBAPP_URL")

def get_events_by_bounding_box(page):
    """
    要素の画面上の座標（Bounding Box）を基準に、日付とイベントを紐付ける最終ロジック。
    """
    events = []
    month_year = page.locator('time').get_attribute('datetime')

    # 1. 全ての日付セルの日付と座標を取得
    date_boxes = []
    gridcells = page.locator('[role="gridcell"]').all()
    for cell in gridcells:
        # セル内の日付番号要素を取得 (div > div 構造を仮定)
        day_element = cell.locator('div > div')
        if day_element.count() > 0:
            day = day_element.inner_text()
            if day.isdigit():
                box = cell.bounding_box()
                if box:
                    date_boxes.append({'day': day, 'box': box})

    if not date_boxes:
        print("Error: Could not find or measure date cells.")
        return []
    
    print(f"Found and measured {len(date_boxes)} date cells.")

    # 2. 全てのイベントのタイトル、時間、座標を取得
    event_details = []
    event_elements = page.locator('.lndlxo5').all()


    for i,event_element in enumerate(event_elements):
        box = event_element.bounding_box()
        if not box:
            continue
        
        button = event_element.locator('button')
        if button.count() > 0:
            title_element = button.locator('.lndlxo9')
            time_element = button.locator('._1r1c5vla')
            
            title = ""
            if title_element.count() > 0:
                title = title_element.inner_text()
            else:
                full_text = button.inner_text()
                time_text = time_element.inner_text() if time_element.count() > 0 else ""
                title = full_text.replace(time_text, "").strip()
                print(full_text + " " + time_text + " " + title)
                print('full_text + " " + time_text + " " + title')

            time = time_element.inner_text() if time_element.count() > 0 else None

            print(time)
            print('time\n')

            button.click()
            page.wait_for_timeout(500)
            memo=None
            memo = page.locator('p.exlc7u1.vjrcbi0')
            if memo.count() >0:
                if memo.inner_text().find('Locator') == -1:
                    memo = memo.inner_text()
                    print(memo)
            else:
                memo = None

            if title != "" and time != None:
                event_details.append({
                    'title': title.strip(),
                    'time': time,
                    'box': box,
                    'memo': memo
                })
            closebotton = page.get_by_label("Close")
            if closebotton.count() > 0:
                closebotton.click()
                page.wait_for_timeout(500)


    if not event_details:
        print("Warning: Found date cells, but no event elements.")
        return []
        
    print(f"Found and measured {len(event_details)} events.")

    print(event_details)
    print('event_details_1')

    # 3. イベントの座標がどの日付セルの範囲内にあるかを判定して紐付け
    for event_detail in event_details:
        event_box = event_detail['box']
        # イベントの中心点がどのセルに入るかで判定
        event_center_x = event_box['x'] + event_box['width'] / 2
        event_center_y = event_box['y'] + event_box['height'] / 2

        for date_info in date_boxes:
            date_box = date_info['box']
            if (date_box['x'] <= event_center_x < date_box['x'] + date_box['width'] and
                date_box['y'] <= event_center_y < date_box['y'] + date_box['height']):
                
                event = {
                    'date': f"{month_year}-{str(date_info['day']).zfill(2)}",
                    'time': event_detail['time'],
                    'title': event_detail['title'],
                    'memo': event_detail['memo']
                }
                if event not in events:
                    events.append(event)
                break # マッチしたら次のイベントへ
    
    print(events)
    print('events_2')
    
    return events

def main():
    with sync_playwright() as p:
        browser = p.chromium.launch(
            headless=True,
            args=["--force-device-scale-factor=1.1"]
            )
        
        # 日本のタイムゾーン（Asia/Tokyo）を指定して、新しいブラウザコンテキストを作成
        context = browser.new_context(
            timezone_id="Asia/Tokyo"
        )
        page = browser.new_page()

        print("Navigating to calendar and logging in...")
        page.goto(CALENDAR_URL, wait_until="networkidle")
        
        if "signin" in page.url:
            print("Login page detected. Logging in...")
            page.fill('input[type="email"]', TIMETREE_EMAIL)
            page.fill('input[type="password"]', TIMETREE_PASSWORD)
            page.click('button[type="submit"]')
        
        print("Waiting for calendar to load...")
        page.wait_for_selector('[data-test-id="calendar-main"]')
        page.wait_for_timeout(5000)
        print("Calendar loaded.")

        # 新しいスクレイピング関数を呼び出す
        events = get_events_by_bounding_box(page)
        

        print("\n--- Scraped Events ---")
        # 日付順にソートして表示
        sorted_events = sorted(events, key=lambda x: (x['date'], x['time'] or ''))
        print(json.dumps(sorted_events, indent=2, ensure_ascii=False))

        if not events:
            print("\nWarning: No events were scraped. Skipping sending data to GAS.")
        elif GAS_WEBAPP_URL:
            print("\n--- Sending data to Google Apps Script ---")
            try:
                headers = {'Content-Type': 'application/json'}
                # ソートした結果を送信
                response = requests.post(GAS_WEBAPP_URL, data=json.dumps(sorted_events), headers=headers)
                response.raise_for_status()
                print(f"Successfully sent data. Status: {response.status_code}")
                print(f"Response from GAS: {response.text}")
            except requests.exceptions.RequestException as e:
                print(f"Error sending data to GAS: {e}")
        else:
            print("\nGAS_WEBAPP_URL is not set. Skipping sending data to GAS.")

        browser.close()

if __name__ == "__main__":
    main()


---


- フォルダ名: ./.github/workflows
- ファイル名: main.yml
- 内容:
# GitHub Actionsワークフローファイル
# ファイル名: .github/workflows/main.yml

name: Scrape TimeTree and Update G-Calendar

on:
  schedule:
    - cron: "0 */1 * * *"
  workflow_dispatch:

jobs:
  scrape-and-update:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Tokyo

    steps:
      # 1. リポジトリのコードをチェックアウト
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Python環境をセットアップ
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip' # pipのキャッシュはこれが一番シンプルで十分

      # 3. 依存ライブラリをインストール
      - name: Install Python dependencies
        run: pip install -r requirements.txt
      
      # ★★★ ここからがQiita記事のアイデアを取り入れた修正部分 ★★★
      # https://qiita.com/ohakutsu/items/8e4c10cad360bf4cda04

      # 4. Playwrightのバージョンを取得
      - name: Get Playwright version
        id: playwright-version
        run: |
          echo "VERSION=$(pip show playwright | grep Version | cut -d ' ' -f 2)" >> $GITHUB_ENV
      
      # 5. Playwrightのブラウザをキャッシュ
      #    キャッシュキーにPlaywrightのバージョンを含める
      - name: Cache Playwright browsers
        id: cache-playwright # このステップにIDを付けて後で参照する
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ env.VERSION }}-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-playwright-${{ env.VERSION }}-

      # 6. Playwrightのブラウザと依存関係をインストール
      #    【重要】キャッシュがヒットしなかった場合のみ、このステップを実行する
      - name: Install Playwright browsers and dependencies
        if: steps.cache-playwright.outputs.cache-hit != 'true'
        run: playwright install --with-deps

      # ★★★ 修正ここまで ★★★

      # 7. Pythonスクリプトを実行
      - name: Run scraper script
        env:
          TIMETREE_EMAIL: ${{ secrets.TIMETREE_EMAIL }}
          TIMETREE_PASSWORD: ${{ secrets.TIMETREE_PASSWORD }}
          TIMETREE_CALENDAR_URL: ${{ secrets.TIMETREE_CALENDAR_URL }}
          GAS_WEBAPP_URL: ${{ secrets.GAS_WEBAPP_URL }}
        run: python timetree_scraper.py

      # 8. 実行結果をジョブサマリーに計算して出力
      - name: Calculate and Post Execution Summary
        # ジョブが成功しても失敗しても、必ずこのステップを実行する
        if: always()
        # 公式のgithub-scriptアクションを使用
        uses: actions/github-script@v7
        with:
          script: |
            // ワークフローの開始時刻と現在時刻（このステップの実行時刻）を取得
            const startTime = new Date('${{ job.started_at }}');
            const endTime = new Date();
            
            // ミリ秒単位で差を計算
            const durationMs = endTime - startTime;
            
            // 分と秒に変換
            const minutes = Math.floor(durationMs / 60000);
            const seconds = ((durationMs % 60000) / 1000).toFixed(0);
            const durationStr = `${minutes}分 ${seconds}秒`;

            const jstOptions = {
              timeZone: 'Asia/Tokyo',
              year: 'numeric', month: '2-digit', day: '2-digit',
              hour: '2-digit', minute: '2-digit', second: '2-digit',
              hour12: false // 24時間表記
            };

            // JSTに変換した文字列を取得
            //const startTimeJST = startTime.toLocaleString('ja-JP', jstOptions);
            const endTimeJST = endTime.toLocaleString('ja-JP', jstOptions);
            
            // ジョブサマリーを生成
            await core.summary
              .addHeading('実行結果サマリー', 2) // h2見出し
              .addList([
                `ワークフロー名 : ${{ github.workflow }}`,
                `実行トリガー   : \`${{ github.event_name }}\``,
                `ステータス     : ${'${{ job.status }}' === 'success' ? ' 成功 ✅' : ' 失敗 ❌'}`
              ])
              .addHeading('実行日時', 3) // h3見出し
              .addTable([
                [ {data: '終了 (JST)', header: true} ],
                [  endTimeJST ]
              ])
              .write(); // サマリーに書き込む